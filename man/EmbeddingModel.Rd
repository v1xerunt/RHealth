% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Model_EmbeddingModel.R
\name{EmbeddingModel}
\alias{EmbeddingModel}
\title{EmbeddingModel}
\usage{
EmbeddingModel(dataset, embedding_dim = 128)
}
\arguments{
\item{dataset}{A SampleDataset object containing input_processors.}

\item{embedding_dim}{Integer embedding dimension. Default is 128.}
}
\value{
An \code{EmbeddingModel} object that inherits from \code{BaseModel}.

None (initializes fields inside the object).

A named list of \code{torch_tensor} objects after embedding (or passthrough).

A character string representation.
}
\description{
EmbeddingModel is responsible for creating embedding layers for different types of input data.

Initialize an EmbeddingModel by constructing embedding layers based on input processors.

Perform a forward pass by computing embeddings (or passing through) for each field.
This method takes \code{inputs}, a named list of \code{torch_tensor} objects, with names matching dataset$input_processors.

Return a concise string representation of the EmbeddingModel, listing its embedding layers.
}
\details{
Inherits from BaseModel. For each entry in \code{dataset$input_processors}, if the processor is a
\code{SequenceProcessor}, an embedding layer (\code{nn_embedding}) is created; if it is a \code{TimeseriesProcessor},
a linear layer (\code{nn_linear}) is created. During the forward pass, each input tensor is moved to the
model’s device; if an embedding layer exists for that field, it is applied to the tensor. Otherwise,
the tensor is passed through unchanged.
}
\section{Fields}{

\describe{
\item{\code{embedding_layers}}{A \code{nn_module_dict} of submodules, one embedding (or linear) layer per field.}
}}

\examples{
\dontrun{
# Assume `my_dataset` is a SampleDataset with input_processors that includes
# SequenceProcessor and/or TimeseriesProcessor instances.

model <- EmbeddingModel(dataset = my_dataset, embedding_dim = 128)
# Suppose `inputs` is a named list of torch tensors, e.g.:
inputs <- list(
  sequence_field   = torch_tensor(matrix(sample(1:100, 16), nrow = 4, ncol = 4)),
  timeseries_field = torch_tensor(matrix(rnorm(20), nrow = 5, ncol = 4))
)
outputs <- model(inputs)
# `outputs` is a named list of embedded tensors:
#   - For “sequence_field”, a tensor of shape (batch_size, seq_len, embedding_dim)
#   - For “timeseries_field”, a tensor of shape (batch_size, embedding_dim)
}

}
